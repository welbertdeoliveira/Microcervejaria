//************************************************************************************
//**  
//**  File name:     C:\Users\Beto\Desktop\CERVEJARIA\CODIGOS\FLUXOGRAMAS FLOWCODE\PRINCIPAL.c
//**  Generated by:  Flowcode v4.3.7.63
//**  Date:          Sunday, January 27, 2013 19:39:55
//**  Licence:       Professional
//**  Registered to: 20ACM8
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Definições para o microcontrolador
#define P16F877A
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_C
#define MX_SPI_SDI 4
#define MX_SPI_SDO 5
#define MX_SPI_SCK 3
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_C
#define MX_I2C_SDA 4
#define MX_I2C_SCL 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1

//Funções
#define MX_CLK_SPEED 10000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuração de dados
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f3a
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f3a);
#endif

//Funções internas
#include "C:\Program Files\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Declarações da função Macro
void FCM_RS232();


//Declarações da variável
#define FCSZ_STRING 4
#define FCSZ_MOST 4
#define FCSZ_FERV 4
float FCV_AUX;
float FCV_PWM;
char FCV_STRING[FCSZ_STRING];
char FCV_MOST[FCSZ_MOST];
char FCV_FERV[FCSZ_FERV];
float FCV_FERV_REAL;
short FCV_INTEIRO;
float FCV_MOST_REAL;
short FCV_RCV;


//Defines:

/**** Macro Substitutions ****
portb = D1 Port
trisb = D1 Data Direction
portb = D2 Port
trisb = D2 Data Direction
portb = D3 Port
trisb = D3 Data Direction
portb = D4 Port
trisb = D4 Data Direction
portb = RS Port
trisb = RS Data Direction
portb = E Port
trisb = E Data Direction
0 = Data 1_Pin
1 = Data 2 Pin
2 = Data 3 Pin
3 = Data 4 Pin
4 = RS Pin
5 = Enable Pin
LCD_524892 = Unique Component Reference Number
2 = Row Count
16 = Column Count
******************************/

	//component connections
	#define LCD_524892_PORT0    portb
	#define LCD_524892_TRIS0    trisb
	#define LCD_524892_PORT1    portb
	#define LCD_524892_TRIS1    trisb
	#define LCD_524892_PORT2    portb
	#define LCD_524892_TRIS2    trisb
	#define LCD_524892_PORT3    portb
	#define LCD_524892_TRIS3    trisb
	#define LCD_524892_PORT4    portb
	#define LCD_524892_TRIS4    trisb
	#define LCD_524892_PORT5    portb
	#define LCD_524892_TRIS5    trisb
	#define LCD_524892_BIT0    	0
	#define LCD_524892_BIT1    	1
	#define LCD_524892_BIT2    	2
	#define LCD_524892_BIT3    	3
	#define LCD_524892_RS      	4
	#define LCD_524892_E       	5
	#define LCD_524892_ROWCNT	2
	#define LCD_524892_COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_524892_DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_524892_DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_524892_DELAY   __delay_us(120)
	#endif
	#ifndef LCD_524892_DELAY
	  #define LCD_524892_DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Declarações da função Macro

void FCD_LCDDisplay0_RawSend(char in, char mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(char Character);
void FCD_LCDDisplay0_Command(char in);
void FCD_LCDDisplay0_Cursor(char x, char y);
void FCD_LCDDisplay0_PrintNumber(short Number);
void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions);
void FCD_LCDDisplay0_ClearLine(char Line);
void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7);
//Defines:

/**** Macro Substitutions ****
0 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
1 = VRef+ Option
500 = VRef Voltage x 0.01V
******************************/




//ADC(0): //Declarações da função Macro

void FCD_ADC0_SampleADC();
char FCD_ADC0_ReadAsByte();
short FCD_ADC0_ReadAsInt();
float FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);
//Defines:

/**** Macro Substitutions ****
1 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
1 = VRef+ Option
500 = VRef Voltage x 0.01V
******************************/




//ADC(1): //Declarações da função Macro

void FCD_ADC1_SampleADC();
char FCD_ADC1_ReadAsByte();
short FCD_ADC1_ReadAsInt();
float FCD_ADC1_ReadAsVoltage();
void FCD_ADC1_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);
//Defines:

/**** Macro Substitutions ****
portc = RTS Port
trisc = RTS Data Direction
portc = CTS Port
trisc = CTS Data Direction
0 = RTS Pin
4 = CTS Pin
1 = UART Selection		(0-SW / 1-UART1 / 2-UART2)
0 = Flow Control		(0-Off / 1-On)
0 = Debug Enable		(0-Off / 1-On)
0 = Echo Enable		(0-Off / 1-On)
4 = UART TXSTA Value
64 = UART SPBRG Value
RS232_131824 = Unique ID
Unused = Bitbanged Receive Port Register
Unused = Bitbanged Receive Data Direction Register
Unused = Bitbanged Receive Pin
Unused = Bitbanged Transmit Pin
120 = Bitbanged BAUD Rate Delay
0 = Timout	Selection	(0-Legacy / 1-MS Timeout)
0 = Data Size			(0-8 bits / 1-9 bits / 2-7 bits & Only available on BitBanged components)
0 = Parity Enable		(0-No Parity / 1-Odd Parity / 2-Even Parity)
0 = Legacy Return		(0-Legacy mode return 255 / 1-New mode return MSB err flags)
Unused = Bitbanged Transmit Port Register
Unused = Bitbanged Transmit Data Direction Register
******************************/

#define RS232_131824_RTS_PORT			portc
#define RS232_131824_RTS_TRIS			trisc
#define RS232_131824_CTS_PORT			portc
#define RS232_131824_CTS_TRIS			trisc
#define RS232_131824_RTS_PIN			0
#define RS232_131824_CTS_PIN			4
#define RS232_131824_UART				1
#define RS232_131824_TOUT  			0
#define RS232_131824_DATASIZE			0
#define RS232_131824_PARITY			0
#define RS232_131824_LEGACY_RV			0

#if (0 == 1)
  	#define RS232_131824_HARDWARE
#endif

#if (0 == 1)
  	#define RS232_131824_DEBUG
#endif

#if (0 == 1)
  	#define RS232_131824_ECHO
#endif

#if (RS232_131824_UART == 0)
	#define RS232_131824_RX_PORT		Unused
	#define RS232_131824_RX_TRIS		Unused
	#define RS232_131824_SW_RX		Unused
	#define RS232_131824_SW_TX		Unused
	#define RS232_131824_SW_BAUD		120
	#define RS232_131824_TX_PORT		Unused
	#define RS232_131824_TX_TRIS		Unused
#else
	#define RS232_131824_TXSTA_VAL  	4
	#define RS232_131824_SPBRG_VAL  	64
	#define RS232_131824_SW_BAUD		0
#endif

#if (RS232_131824_LEGACY_RV == 0)
	#if (RS232_131824_DATASIZE == 1)
		#ifdef _BOOSTC
			#pragma error "Chip does not have second UART capability"
		#endif
		#ifdef HI_TECH_C
			#error "Chip does not have second UART capability"
		#endif
	#endif
#endif

#define RS232_131824_STATUS_LOOP		0
#define RS232_131824_STATUS_TIMEOUT	1
#define RS232_131824_STATUS_RXBYTE	2





//RS232(0): //Declarações da função Macro

void FCD_RS2320_SendRS232Char(short nChar);
void FCD_RS2320_SendRS232String(char* String, char MSZ_String);
short FCD_RS2320_ReceiveRS232Char(short nTimeout);
void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes);
void FCD_RS2320_RS232_Delay(char mode);



//LCDDisplay(0): //Implementações Macro


void FCD_LCDDisplay0_RawSend(char in, char mask)
{
		unsigned char pt;

		clear_bit(LCD_524892_PORT0, LCD_524892_BIT0);
		clear_bit(LCD_524892_PORT1, LCD_524892_BIT1);
		clear_bit(LCD_524892_PORT2, LCD_524892_BIT2);
		clear_bit(LCD_524892_PORT3, LCD_524892_BIT3);
		clear_bit(LCD_524892_PORT4, LCD_524892_RS);
		clear_bit(LCD_524892_PORT5, LCD_524892_E);
		pt = ((in >> 4) & 0x0f);
		if (pt & 0x01)
		    set_bit(LCD_524892_PORT0, LCD_524892_BIT0);
		if (pt & 0x02)
		    set_bit(LCD_524892_PORT1, LCD_524892_BIT1);
		if (pt & 0x04)
		    set_bit(LCD_524892_PORT2, LCD_524892_BIT2);
		if (pt & 0x08)
		    set_bit(LCD_524892_PORT3, LCD_524892_BIT3);
		if (mask)
		    set_bit(LCD_524892_PORT4, LCD_524892_RS);
		LCD_524892_DELAY;
		set_bit (LCD_524892_PORT5, LCD_524892_E);
		LCD_524892_DELAY;
		clear_bit (LCD_524892_PORT5, LCD_524892_E);
		pt = (in & 0x0f);
		LCD_524892_DELAY;
		clear_bit(LCD_524892_PORT0, LCD_524892_BIT0);
		clear_bit(LCD_524892_PORT1, LCD_524892_BIT1);
		clear_bit(LCD_524892_PORT2, LCD_524892_BIT2);
		clear_bit(LCD_524892_PORT3, LCD_524892_BIT3);
		clear_bit(LCD_524892_PORT4, LCD_524892_RS);
		clear_bit(LCD_524892_PORT5, LCD_524892_E);
		if (pt & 0x01)
		    set_bit(LCD_524892_PORT0, LCD_524892_BIT0);
		if (pt & 0x02)
		    set_bit(LCD_524892_PORT1, LCD_524892_BIT1);
		if (pt & 0x04)
		    set_bit(LCD_524892_PORT2, LCD_524892_BIT2);
		if (pt & 0x08)
		    set_bit(LCD_524892_PORT3, LCD_524892_BIT3);
		if (mask)
		    set_bit(LCD_524892_PORT4, LCD_524892_RS);
		LCD_524892_DELAY;
		set_bit (LCD_524892_PORT5, LCD_524892_E);
		LCD_524892_DELAY;
		clear_bit (LCD_524892_PORT5, LCD_524892_E);
		LCD_524892_DELAY;
}

void FCD_LCDDisplay0_Start()
{
	
		clear_bit(LCD_524892_TRIS0, LCD_524892_BIT0);
		clear_bit(LCD_524892_TRIS1, LCD_524892_BIT1);
		clear_bit(LCD_524892_TRIS2, LCD_524892_BIT2);
		clear_bit(LCD_524892_TRIS3, LCD_524892_BIT3);
		clear_bit(LCD_524892_TRIS4, LCD_524892_RS);
		clear_bit(LCD_524892_TRIS5, LCD_524892_E);

		Wdt_Delay_Ms(12);

		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x32, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x2c, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x06, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x0c, 0);
		Wdt_Delay_Ms(2);

		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Clear()
{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintASCII(char Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(char in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(char x, char y)
{
	
	  #if (LCD_524892_ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_524892_ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_524892_ROWCNT == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;

		#if (LCD_524892_COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_524892_COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintNumber(short Number)
{
	
		short tmp_int;
		char tmp_byte;
		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String)
{
	
		char idx = 0;

		for (idx=0; idx<MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
				{
					break;
				}
				FCD_LCDDisplay0_RawSend(String[idx], 0x10);
			#endif

			#ifdef HI_TECH_C
				if (*String == 0)
				{
					break;
				}
				FCD_LCDDisplay0_RawSend(*String, 0x10);
				String++;
			#endif
		}

}

void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions)
{
	
		char cmd = 0;
		char count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(char Line)
{
	
		char count;
		char rowcount;

		//Define number of columns per line
		#if (LCD_524892_ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_524892_ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_524892_ROWCNT == 4)
			#if (LCD_524892_COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_524892_COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7)
{
	   //set CGRAM address
	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);
}



//ADC(0): //Implementações Macro


void FCD_ADC0_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
	// 16C76, 16F76, 16C77, 16F77, 16F818, 16F819, 16F870, 16F871, 16F872, 16F873, 16F873A,
	// 16F874, 16F874A, 16F876, 16F876A, 16F877, 16F877A,
	******************************************************************************************/

		#define MX_ADC_CHANNEL		0
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		1

		//set up ADC conversion
		char old_tris, cnt;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_MSK  0x01
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x0E;
			#else
				adcon1 = 0x05;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_MSK  0x02
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x04;
			#else
				adcon1 = 0x05;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_MSK  0x04
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x02;
			#else
				adcon1 = 0x03;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_MSK  0x08
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x04;
			#else
				#ifdef _BOOSTC
					#pragma error "Target device is currently using AN3 for VREF+"
				#endif
				#ifdef HI_TECH_C
					#error Target device is currently using AN3 for VREF+
				#endif
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_MSK  0x20
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x02;
			#else
				adcon1 = 0x03;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_MSK  0x01
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x09;
			#else
				adcon1 = 0x01;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_MSK  0x02
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x00;
			#else
				adcon1 = 0x01;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_MSK  0x04
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x00;
			#else
				adcon1 = 0x01;
			#endif
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#ifdef _BOOSTC
				#pragma error "ADC Type 1 conversion code error - please contact technical support"
			#endif
			#ifdef HI_TECH_C
				#error ADC Type 1 conversion code error - please contact technical support
			#endif
		#endif

		//assign conversion speed
		#if (MX_ADC_CONV_SP > 3)
			st_bit(adcon1, ADCS2);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = (0x01 | (MX_ADC_CONV_SP << 6)) | (MX_ADC_CHANNEL << 3);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x04;
		while (adcon0 & 0x04);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x07;
		adcon0 = 0x00;

		#undef MX_ADC_CHANNEL
		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

}

char FCD_ADC0_ReadAsByte()
{
	
		FCD_ADC0_SampleADC();

		return adresh;

}

short FCD_ADC0_ReadAsInt()
{
	
		short iRetVal;

		FCD_ADC0_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);

		return (iRetVal);

}

float FCD_ADC0_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC0_ReadAsInt();											//Read as 10-bit Integer

		#ifdef _BOOSTC
			fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
			fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
			fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
			fSample = float32_from_int32(iSample);							//Convert to floating point variable
			fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage
		#endif

		#ifdef HI_TECH_C
			fVoltage = MX_ADC_VREF_V;										//Convert reference voltage count to floating point (0 - 500 x 10mV)
			fVoltage = fVoltage * 0.01;										//Convert reference voltage count to actual voltage (0 - 5)
			fVperDiv = fVoltage * 0.000976;									//Convert actual voltage to voltage per division (VRef / 1024)
			fSample = iSample;												//Convert to floating point variable
			fVoltage = fSample * fVperDiv;									//Calculate floating point voltage
		#endif

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//ADC(1): //Implementações Macro


void FCD_ADC1_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
	// 16C76, 16F76, 16C77, 16F77, 16F818, 16F819, 16F870, 16F871, 16F872, 16F873, 16F873A,
	// 16F874, 16F874A, 16F876, 16F876A, 16F877, 16F877A,
	******************************************************************************************/

		#define MX_ADC_CHANNEL		1
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		1

		//set up ADC conversion
		char old_tris, cnt;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_MSK  0x01
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x0E;
			#else
				adcon1 = 0x05;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_MSK  0x02
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x04;
			#else
				adcon1 = 0x05;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_MSK  0x04
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x02;
			#else
				adcon1 = 0x03;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_MSK  0x08
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x04;
			#else
				#ifdef _BOOSTC
					#pragma error "Target device is currently using AN3 for VREF+"
				#endif
				#ifdef HI_TECH_C
					#error Target device is currently using AN3 for VREF+
				#endif
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_MSK  0x20
			#define MX_ADC_TRIS_REG  trisa
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x02;
			#else
				adcon1 = 0x03;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_MSK  0x01
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x09;
			#else
				adcon1 = 0x01;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_MSK  0x02
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x00;
			#else
				adcon1 = 0x01;
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_MSK  0x04
			#define MX_ADC_TRIS_REG  trise
			#if (MX_ADC_VREF_OPT == 0)
				adcon1 = 0x00;
			#else
				adcon1 = 0x01;
			#endif
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#ifdef _BOOSTC
				#pragma error "ADC Type 1 conversion code error - please contact technical support"
			#endif
			#ifdef HI_TECH_C
				#error ADC Type 1 conversion code error - please contact technical support
			#endif
		#endif

		//assign conversion speed
		#if (MX_ADC_CONV_SP > 3)
			st_bit(adcon1, ADCS2);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = (0x01 | (MX_ADC_CONV_SP << 6)) | (MX_ADC_CHANNEL << 3);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x04;
		while (adcon0 & 0x04);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x07;
		adcon0 = 0x00;

		#undef MX_ADC_CHANNEL
		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

}

char FCD_ADC1_ReadAsByte()
{
	
		FCD_ADC1_SampleADC();

		return adresh;

}

short FCD_ADC1_ReadAsInt()
{
	
		short iRetVal;

		FCD_ADC1_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);

		return (iRetVal);

}

float FCD_ADC1_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC1_ReadAsInt();											//Read as 10-bit Integer

		#ifdef _BOOSTC
			fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
			fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
			fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
			fSample = float32_from_int32(iSample);							//Convert to floating point variable
			fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage
		#endif

		#ifdef HI_TECH_C
			fVoltage = MX_ADC_VREF_V;										//Convert reference voltage count to floating point (0 - 500 x 10mV)
			fVoltage = fVoltage * 0.01;										//Convert reference voltage count to actual voltage (0 - 5)
			fVperDiv = fVoltage * 0.000976;									//Convert actual voltage to voltage per division (VRef / 1024)
			fSample = iSample;												//Convert to floating point variable
			fVoltage = fSample * fVperDiv;									//Calculate floating point voltage
		#endif

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC1_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC1_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//RS232(0): //Implementações Macro


void FCD_RS2320_SendRS232Char(short nChar)
{
	
	#if (RS232_131824_UART == 0)

		char dMask;
		char idx;
		char count = 8;

		#ifdef RS232_131824_HARDWARE
			//wait until CTS is low
			while (( RS232_131824_CTS_PORT & (1 << RS232_131824_CTS_PIN) ) != 0);
		#endif

		#if(RS232_131824_DATASIZE == 1)
			count = 9;
		#endif
		#if(RS232_131824_DATASIZE == 2)
			count = 7;
		#endif

		clear_bit( RS232_131824_TX_PORT, RS232_131824_SW_TX);			// Send Start bit
		FCD_RS2320_RS232_Delay(0);

		for (idx = 0; idx < count; idx++)
		{
			dMask = nChar & 0x01;					// Mask off data bit

			if (dMask)
				set_bit( RS232_131824_TX_PORT, RS232_131824_SW_TX);
			else
				clear_bit( RS232_131824_TX_PORT, RS232_131824_SW_TX);

			FCD_RS2320_RS232_Delay(0);
			nChar = nChar >> 1;						// Move to next data bit
		}

		set_bit( RS232_131824_TX_PORT, RS232_131824_SW_TX);				// Send Stop bit
		FCD_RS2320_RS232_Delay(0);

	#endif

	#if (RS232_131824_UART == 1)

		#ifndef MX_UART
			#ifdef _BOOSTC
				#pragma error "Chip does not have second UART capability"
			#endif
			#ifdef HI_TECH_C
				#error "Chip does not have second UART capability"
			#endif
		#endif

		st_bit(txsta, TXEN);
		while (ts_bit(pir1, TXIF) == 0);

		#ifdef RS232_131824_HARDWARE
			//wait until CTS is low
			while (( RS232_131824_CTS_PORT & (1 << RS232_131824_CTS_PIN) ) != 0);
		#endif

		#if(RS232_131824_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
		#endif

		txreg = nChar;

	#endif

	#if (RS232_131824_UART == 2)

		#ifndef MX_UART2
			#ifdef _BOOSTC
				#pragma error "Chip does not have second UART capability"
			#endif
			#ifdef HI_TECH_C
				#error "Chip does not have second UART capability"
			#endif
		#endif

		st_bit(txsta2, TXEN);
		while (ts_bit(pir3, TX2IF) == 0);

		#ifdef RS232_131824_HARDWARE
			//wait until CTS is low
			while (( RS232_131824_CTS_PORT & (1 << RS232_131824_CTS_PIN) ) != 0);
		#endif

		#if( RS232_131824_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta2, TX9D);
			else
				cr_bit(txsta2, TX9D);
		#endif

		txreg2 = nChar;

	#endif

}

void FCD_RS2320_SendRS232String(char* String, char MSZ_String)
{
		char idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
					break;
				else FCD_RS2320_SendRS232Char(String[idx]);
			#endif
			#ifdef HI_TECH_
				if (*String == 0)
					break;
				else FCD_RS2320_SendRS232Char(*String);
				String++;
			#endif
		}
}

short FCD_RS2320_ReceiveRS232Char(short nTimeout)
{
	
		char delay1 = 0;
		char delay2 = 0;
		char regcheck = 0;
		char dummy = 0;
		short retVal = 512;
		char bWaitForever = 0;
		char rxStatus = RS232_131824_STATUS_LOOP;
		char idx;
		char count = 8;

		#if ( RS232_131824_LEGACY_RV == 0)
			retVal = 255;
		#endif

		#if ( RS232_131824_UART == 1)
			#ifndef MX_UART
				#ifdef _BOOSTC
					#pragma error "Chip does not have second UART capability"
				#endif
				#ifdef HI_TECH_C
					#error "Chip does not have second UART capability"
				#endif
			#endif
		#endif

		#if ( RS232_131824_UART == 2)
			#ifndef MX_UART2
				#ifdef _BOOSTC
					#pragma error "Chip does not have second UART capability"
				#endif
				#ifdef HI_TECH_C
					#error "Chip does not have second UART capability"
				#endif
			#endif
		#endif

		#ifdef RS232_131824_HARDWARE
			//ready to accept data
			clear_bit( RS232_131824_RTS_PORT, RS232_131824_RTS_PIN);
		#endif

		if (nTimeout == 255)
			bWaitForever = 1;

		#if ( RS232_131824_UART == 1)
			st_bit(rcsta, CREN);
		#endif

		#if ( RS232_131824_UART == 2)
			st_bit(rcsta2, CREN);
		#endif

		while (rxStatus == RS232_131824_STATUS_LOOP)
		{
			if (bWaitForever == 0)
			{
				//don't wait forever, so do timeout thing...
				if (nTimeout == 0)
				{
					rxStatus = RS232_131824_STATUS_TIMEOUT;
				}
				else
				{
					if ( RS232_131824_TOUT)
					{
						delay_us(10);
						delay1 = delay1 + 1;
						if(delay1 == 100)
						{
							nTimeout = nTimeout - 1;
							delay1 = 0;
						}
					}
					else
					{
						//decrement timeout
						delay1 = delay1 - 1;
						if (delay1 == 0)
						{
							nTimeout = nTimeout - 1;
						}
					}
				}
			}

			#if ( RS232_131824_UART == 0)
				regcheck = test_bit(RS232_131824_RX_PORT, RS232_131824_SW_RX);	//Test for start bit
				if (regcheck == 0)
					rxStatus = RS232_131824_STATUS_RXBYTE;
			#endif

			#if ( RS232_131824_UART == 1)
				regcheck = ts_bit(pir1, RCIF);
				if (regcheck != 0)
					rxStatus = RS232_131824_STATUS_RXBYTE;
			#endif

			#if ( RS232_131824_UART == 2)
				regcheck = ts_bit(pir3, RC2IF);
				if (regcheck != 0)
					rxStatus = RS232_131824_STATUS_RXBYTE;
			#endif
		}

		if (rxStatus == RS232_131824_STATUS_RXBYTE)
		{
			#if ( RS232_131824_UART > 0)

				#if ( RS232_131824_UART == 1)
					regcheck = ts_bit(rcsta, FERR);
				#endif

				#if ( RS232_131824_UART == 2)
					regcheck = ts_bit(rcsta2, FERR);
				#endif

				if (regcheck != 0)
				{
					#if ( RS232_131824_UART == 1)
						dummy = rcreg;      //need to read the rcreg to clear FERR
					#endif

					#if ( RS232_131824_UART == 2)
						dummy = rcreg2;      //need to read the rcreg to clear FERR
					#endif

					#ifdef RS232_131824_DEBUG
						FCD_RS2320_SendRS232Char('<');
						FCD_RS2320_SendRS232Char('F');
						FCD_RS2320_SendRS232Char('E');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('>');
					#endif

					#if ( RS232_131824_LEGACY_RV == 1)
						retVal = 0x400;					//Framing Error Flag
					#endif
				}
				else
				{
					#if ( RS232_131824_UART == 1)
						regcheck = ts_bit(rcsta, OERR);
					#endif

					#if ( RS232_131824_UART == 2)
						regcheck = ts_bit(rcsta2, OERR);
					#endif

					if (regcheck != 0)
					{
						//need to read the rcreg to clear error
						#if ( RS232_131824_UART == 1)
							cr_bit(rcsta, CREN);
							st_bit(rcsta, CREN);
						#endif

						#if ( RS232_131824_UART == 2)
							cr_bit(rcsta2, CREN);
							st_bit(rcsta2, CREN);
						#endif

						#ifdef RS232_131824_DEBUG
							FCD_RS2320_SendRS232Char('<');
							FCD_RS2320_SendRS232Char('O');
							FCD_RS2320_SendRS232Char('E');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('>');
						#endif

						#if ( RS232_131824_LEGACY_RV == 1)
							retVal = 0x800;					//Overrun Error Flag
						#endif

					}
					else
					{
						retVal = 0;

						#if ( RS232_131824_UART == 1)

							#if( RS232_131824_DATASIZE == 1)
								if(ts_bit(rcsta, RX9D));
									retVal = 0x100;
							#endif
							retVal = retVal | rcreg; 			//no error, so rx byte is valid

						#endif

						#if ( RS232_131824_UART == 2)

							#if( RS232_131824_DATASIZE == 1)
								if(ts_bit(rcsta2, RX9D));
									retVal = 0x100;
							#endif
							retVal = retVal | rcreg2; 			//no error, so rx byte is valid

						#endif

						#ifdef RS232_131824_ECHO
							FCD_RS2320_SendRS232Char(retVal);
						#endif
					}
				}
			#else
				#if( RS232_131824_DATASIZE == 1)
					count = 9;
				#endif

				FCD_RS2320_RS232_Delay(1);
				for (idx = 0; idx < count; idx++)
				{
					retVal = retVal >> 1;

					if(count == 9)
					{
						if (test_bit( RS232_131824_RX_PORT, RS232_131824_SW_RX))
							retVal = retVal | 0x100;
					}
					else
					{
						if (test_bit( RS232_131824_RX_PORT, RS232_131824_SW_RX))
							retVal = retVal | 0x80;
					}
					FCD_RS2320_RS232_Delay(1);
				}

				#ifdef RS232_131824_ECHO
					FCD_RS2320_SendRS232Char(retVal);
				#endif

			#endif
		}
		#ifdef RS232_131824_HARDWARE
			//not ready to accept data
			set_bit( RS232_131824_RTS_PORT, RS232_131824_RTS_PIN);
		#endif

		return (retVal);
}

void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes)
{
		char idx;
		short in;

		#if ( RS232_131824_LEGACY_RV == 0 )
			#define RS232_TO 	255
		#else
			#define RS232_TO 	256
		#endif

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = FCD_RS2320_ReceiveRS232Char(nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

		#undef RS232_TO
}

void FCD_RS2320_RS232_Delay(char mode)
{
		unsigned int iterations;
		unsigned int delay = RS232_131824_SW_BAUD;

		if (mode)
			delay = delay + 1;

		for (iterations = 0; iterations < delay; iterations++);
}

//Implementações Macro

void FCM_RS232()
{
	
	//Chamar Macro de Componente
	//Chamar Macro de Componente: STRING=RS232(0)::ReceiveRS232String(50, 4)
	FCD_RS2320_ReceiveRS232String(FCV_STRING, 4, 50, 4);


	//Manipulação de String
	//Manipulação de String:
	//  INTEIRO = StringToInt$(STRING)
	FCV_INTEIRO = FCI_STRING_TO_INT(FCV_STRING,FCSZ_STRING);
	

	//Switch
	//Switch: INTEIRO?
	switch (FCV_INTEIRO)
	{
		case 1:
		{
			//Saída
			//Saída: 1 -> D0
			trisd = trisd & 0xfe;
			if (1)
				portd = (portd & 0xfe) | 0x01;
			else
				portd = portd & 0xfe;


			break;
		}

		case 2:
		{
			//Saída
			//Saída: 0 -> D0
			trisd = trisd & 0xfe;
			if (0)
				portd = (portd & 0xfe) | 0x01;
			else
				portd = portd & 0xfe;


			break;
		}

		case 3:
		{
			//Saída
			//Saída: 1 -> D1
			trisd = trisd & 0xfd;
			if (1)
				portd = (portd & 0xfd) | 0x02;
			else
				portd = portd & 0xfd;


			break;
		}

		case 4:
		{
			//Saída
			//Saída: 0 -> D1
			trisd = trisd & 0xfd;
			if (0)
				portd = (portd & 0xfd) | 0x02;
			else
				portd = portd & 0xfd;


			break;
		}

		case 5:
		{
			//Saída
			//Saída: 1 -> D2
			trisd = trisd & 0xfb;
			if (1)
				portd = (portd & 0xfb) | 0x04;
			else
				portd = portd & 0xfb;


			break;
		}

		case 6:
		{
			//Saída
			//Saída: 0 -> D2
			trisd = trisd & 0xfb;
			if (0)
				portd = (portd & 0xfb) | 0x04;
			else
				portd = portd & 0xfb;


			break;
		}

	}


	//Switch
	//Switch: INTEIRO?
	switch (FCV_INTEIRO)
	{
		case 07:
		{
			//Saída
			//Saída: 1 -> D3
			trisd = trisd & 0xf7;
			if (1)
				portd = (portd & 0xf7) | 0x08;
			else
				portd = portd & 0xf7;


			break;
		}

		case 08:
		{
			//Saída
			//Saída: 0 -> D3
			trisd = trisd & 0xf7;
			if (0)
				portd = (portd & 0xf7) | 0x08;
			else
				portd = portd & 0xf7;


			break;
		}

		case 09:
		{
			//Saída
			//Saída: 1 -> D4
			trisd = trisd & 0xef;
			if (1)
				portd = (portd & 0xef) | 0x10;
			else
				portd = portd & 0xef;


			break;
		}

		case 10:
		{
			//Saída
			//Saída: 0 -> D4
			trisd = trisd & 0xef;
			if (0)
				portd = (portd & 0xef) | 0x10;
			else
				portd = portd & 0xef;


			break;
		}

		case 11:
		{
			//Saída
			//Saída: 1 -> D5
			trisd = trisd & 0xdf;
			if (1)
				portd = (portd & 0xdf) | 0x20;
			else
				portd = portd & 0xdf;


			break;
		}

		case 12:
		{
			//Saída
			//Saída: 0 -> D5
			trisd = trisd & 0xdf;
			if (0)
				portd = (portd & 0xdf) | 0x20;
			else
				portd = portd & 0xdf;


			break;
		}

	}


	//Decisão
	//Decisão: INTEIRO > 0?
	if (FCV_INTEIRO > 0)
	{
		//Decisão
		//Decisão: INTEIRO < 13?
		if (FCV_INTEIRO < 13)
		{
			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("ATUANDO NO")
			FCD_LCDDisplay0_PrintString("ATUANDO NO",10);


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Cursor(0, 1)
			FCD_LCDDisplay0_Cursor(0, 1);


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("DISPOSITIVO...")
			FCD_LCDDisplay0_PrintString("DISPOSITIVO...",14);


			//Atraso
			//Atraso: 1 s
			delay_s(1);


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


		}


	}


	//Manipulação de String
	//Manipulação de String:
	//  PWM = StringToFloat$(STRING)
	FCV_PWM = FCI_STRING_TO_FLOAT(FCV_STRING,FCSZ_STRING);
	

	//Cálculo
	//Cálculo:
	//  PWM = PWM
	FCV_PWM = FCV_PWM;
	

	//Decisão
	//Decisão: PWM > 399?
	if (FCV_PWM > 399)
	{
		//Decisão
		//Decisão: PWM > 1000?
		if (FCV_PWM > 1000)
		{
			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("ATUANDO FERV")
			FCD_LCDDisplay0_PrintString("ATUANDO FERV",12);


			//Atraso
			//Atraso: 1 s
			delay_s(1);


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


		} else {
			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("ATUANDO MOST")
			FCD_LCDDisplay0_PrintString("ATUANDO MOST",12);


			//Atraso
			//Atraso: 1 s
			delay_s(1);


			//Chamar Macro de Componente
			//Chamar Macro de Componente: LCDDisplay(0)::Limpar
			FCD_LCDDisplay0_Clear();


		}


	}


}

void main()
{
	
	//Iniciação
	adcon1 = 0x07;

	
	#if (RS232_131824_UART == 0)
		set_bit(RS232_131824_RX_TRIS, RS232_131824_SW_RX);				// Receive pin is a input
		clear_bit(RS232_131824_TX_TRIS, RS232_131824_SW_TX);			// Transmit pin is a output
		set_bit(RS232_131824_TX_PORT, RS232_131824_SW_TX);				// Transmit pin is default high
	#endif

	#if (RS232_131824_UART == 1)
		txsta = RS232_131824_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg = RS232_131824_SPBRG_VAL;   					// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		if(RS232_131824_DATASIZE == 1)
		{
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta, SPEN);         				// turn on serial interface
	#endif

	#if (RS232_131824_UART == 2)

		txsta2 = RS232_131824_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg2 = RS232_131824_SPBRG_VAL;   					// set the baud rate
		rcsta2 = 0;                    				// 8-bit, disabled

		if(RS232_131824_DATASIZE == 1)
		{
			st_bit(txsta2, TX9);   					// 9-bit TX
			st_bit(rcsta2, RX9);                    // 9-bit RX
		}

		st_bit(rcsta2, SPEN);         				// turn on serial interface
	#endif

	#ifdef RS232_131824_HARDWARE
		set_bit( RS232_131824_CTS_TRIS, RS232_131824_CTS_PIN);			//CTS is an input
		clear_bit( RS232_131824_RTS_TRIS, RS232_131824_RTS_PIN);		//RTS is an output
		set_bit( RS232_131824_RTS_PORT, RS232_131824_RTS_PIN); 			//not ready to accept data
	#endif


	//Código de iniciação de interrupção
	option_reg = 0xC0;


	//Saída
	//Saída: 0 -> PORTO D
	trisd = 0x00;
	portd = 0;


	//Chamar Macro de Componente
	//Chamar Macro de Componente: LCDDisplay(0)::Inicializar
	FCD_LCDDisplay0_Start();


	//Chamar Macro de Componente
	//Chamar Macro de Componente: LCDDisplay(0)::Limpar
	FCD_LCDDisplay0_Clear();


	//Chamar Macro de Componente
	//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("CERVEJARIA")
	FCD_LCDDisplay0_PrintString("CERVEJARIA",10);


	//Atraso
	//Atraso: 1 s
	delay_s(1);


	//Chamar Macro de Componente
	//Chamar Macro de Componente: LCDDisplay(0)::Limpar
	FCD_LCDDisplay0_Clear();


	//Ciclo
	//Ciclo: Enquanto1
	while (1)
	{
		//Chamar Macro de Componente
		//Chamar Macro de Componente: MOST_REAL=ADC(0)::LerComoVoltagem
		FCV_MOST_REAL = FCD_ADC0_ReadAsVoltage();


		//Cálculo
		//Cálculo:
		//  AUX = fmul(MOST_REAL, 50)
		FCV_AUX = float32_mul(FCV_MOST_REAL, 50);
		

		//Manipulação de String
		//Manipulação de String:
		//  MOST = FloatToString$(AUX)
		FCI_FLOAT_TO_STRING(FCV_AUX,6,FCV_MOST,FCSZ_MOST);
		

		//Cálculo
		//Cálculo:
		//  AUX = 0
		FCV_AUX = 0;
		

		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("MOST:")
		FCD_LCDDisplay0_PrintString("MOST:",5);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(5, 0)
		FCD_LCDDisplay0_Cursor(5, 0);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString(MOST)
		FCD_LCDDisplay0_PrintString(FCV_MOST,FCSZ_MOST);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(9, 0)
		FCD_LCDDisplay0_Cursor(9, 0);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("oC")
		FCD_LCDDisplay0_PrintString("oC",2);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: FERV_REAL=ADC(1)::LerComoVoltagem
		FCV_FERV_REAL = FCD_ADC1_ReadAsVoltage();


		//Cálculo
		//Cálculo:
		//  AUX = fmul(FERV_REAL, 50)
		FCV_AUX = float32_mul(FCV_FERV_REAL, 50);
		

		//Manipulação de String
		//Manipulação de String:
		//  FERV = FloatToString$(AUX)
		FCI_FLOAT_TO_STRING(FCV_AUX,6,FCV_FERV,FCSZ_FERV);
		

		//Cálculo
		//Cálculo:
		//  AUX = 0
		FCV_AUX = 0;
		

		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(0, 1)
		FCD_LCDDisplay0_Cursor(0, 1);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("FERV:")
		FCD_LCDDisplay0_PrintString("FERV:",5);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(5, 1)
		FCD_LCDDisplay0_Cursor(5, 1);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString(FERV)
		FCD_LCDDisplay0_PrintString(FCV_FERV,FCSZ_FERV);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::Cursor(9, 1)
		FCD_LCDDisplay0_Cursor(9, 1);


		//Chamar Macro de Componente
		//Chamar Macro de Componente: LCDDisplay(0)::EscreverString("oC")
		FCD_LCDDisplay0_PrintString("oC",2);


		//Chamar macro
		//Chamar macro: RS232
		FCM_RS232();


	}


	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



